package autoprovisioning

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/TransparentEdge/terraform-provider-transparentedge/internal/helpers"
	"github.com/TransparentEdge/terraform-provider-transparentedge/internal/teclient"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource                = &customCertificateResource{}
	_ resource.ResourceWithConfigure   = &customCertificateResource{}
	_ resource.ResourceWithImportState = &customCertificateResource{}
)

// helper function to simplify the provider implementation.
func NewCustomCertificate() resource.Resource {
	return &customCertificateResource{}
}

// resource implementation.
type customCertificateResource struct {
	client *teclient.Client
}

// Metadata returns the resource type name.
func (r *customCertificateResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_custom_certificate"
}

// Schema defines the schema for the resource.
func (r *customCertificateResource) Schema(ctx context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description:         "Manages Custom Certificates.",
		MarkdownDescription: "Provides Custom Certificate resource. This allows to create, update and delete custom TLS Certificates.",

		Attributes: map[string]schema.Attribute{
			"id": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
				Description:         "ID of the Custom Certificate.",
				MarkdownDescription: "ID of the Custom Certificate.",
			},
			"commonname": schema.StringAttribute{
				Computed:            true,
				Description:         "CN (Common Name) of the certificate.",
				MarkdownDescription: "CN (_Common Name_) of the certificate.",
			},
			"domains": schema.StringAttribute{
				Computed:            true,
				Description:         "SAN (Subject Alternative Name) domains included in the certificate, including the Common Name.",
				MarkdownDescription: "SAN (_Subject Alternative Name_) domains included in the certificate, including the Common Name.",
			},
			"expiration": schema.StringAttribute{
				Computed:            true,
				Description:         "Date when the certificate will expire.",
				MarkdownDescription: "Date when the certificate will expire.",
			},
			"publickey": schema.StringAttribute{
				Required:            true,
				Description:         "Public part of the certificate in PEM format, it's recommended to include the full chain.",
				MarkdownDescription: "Public part of the certificate in PEM format, it's recommended to include the full chain.",
			},
			"privatekey": schema.StringAttribute{
				Required:            true,
				Description:         "Private part of the certificate in PEM format, the certificate can't be protected with a password.",
				MarkdownDescription: "Private part of the certificate in PEM format, the certificate can't be protected with a password.",
			},
		},
	}
}

// Create
func (r *customCertificateResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	// Retrieve values from plan
	var plan CustomCertificate
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Info(ctx, "Creating Custom Certificate")
	newCustomCertificate := teclient.SSLCustomCertificate{
		Autogenerated: false,
		DNSChallenge:  false,
		PublicKey:     plan.PublicKey.ValueString(),
		PrivateKey:    plan.PrivateKey.ValueString(),
	}
	customCertificateState, errCreate := r.client.CreateCustomCertificate(newCustomCertificate)
	if errCreate != nil {
		resp.Diagnostics.AddError(
			"Error creating Custom Certificate",
			fmt.Sprintf("Could not create the Custom Certificate: %s", errCreate),
		)
		return
	}

	// Sort SAN domains
	sort.Strings(customCertificateState.Domains)
	san_domains := strings.Join(customCertificateState.Domains, ", ")

	// Parse expiration time
	expiration := customCertificateState.Expiration
	exptoint, err := strconv.ParseFloat(customCertificateState.Expiration, 64)
	if err == nil {
		expiration = time.Unix(int64(exptoint), 0).String()
	}

	// Set state to fully populated data
	plan.ID = types.Int64Value(int64(customCertificateState.ID))
	plan.CommonName = types.StringValue(customCertificateState.CommonName)
	plan.Domains = types.StringValue(san_domains)
	plan.Expiration = types.StringValue(expiration)
	// Do not update the plan for public and private key since our API may introduce newlines (or remove)
	//plan.PublicKey = types.StringValue(customCertificateState.PublicKey)
	//plan.PrivateKey = types.StringValue(customCertificateState.PrivateKey)

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *customCertificateResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan CustomCertificate
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Info(ctx, "Updating Custom Certificate")
	existingCustomCertificate := teclient.SSLCustomCertificate{
		ID:            int(plan.ID.ValueInt64()),
		Autogenerated: false,
		DNSChallenge:  false,
		PublicKey:     plan.PublicKey.ValueString(),
		PrivateKey:    plan.PrivateKey.ValueString(),
	}

	customCertificateState, errCreate := r.client.UpdateCustomCertificate(existingCustomCertificate)
	if errCreate != nil {
		resp.Diagnostics.AddError(
			"Error updating Custom Certificate",
			fmt.Sprintf("Could not update the Custom Certificate: %s", errCreate),
		)
		return
	}

	// Sort SAN domains
	sort.Strings(customCertificateState.Domains)
	san_domains := strings.Join(customCertificateState.Domains, ", ")

	// Parse expiration time
	expiration := customCertificateState.Expiration
	exptoint, err := strconv.ParseFloat(customCertificateState.Expiration, 64)
	if err == nil {
		expiration = time.Unix(int64(exptoint), 0).String()
	}

	// Set state to fully populated data
	plan.ID = types.Int64Value(int64(customCertificateState.ID))
	plan.CommonName = types.StringValue(customCertificateState.CommonName)
	plan.Domains = types.StringValue(san_domains)
	plan.Expiration = types.StringValue(expiration)
	// Do not update the plan for public and private key since our API may introduce newlines (or remove)
	//plan.PublicKey = types.StringValue(customCertificateState.PublicKey)
	//plan.PrivateKey = types.StringValue(customCertificateState.PrivateKey)

	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Read resource information
func (r *customCertificateResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	// Get current state
	var state CustomCertificate
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Try to find by ID
	customCertificate, err := r.client.GetCertificate(int(state.ID.ValueInt64()))
	if err != nil {
		resp.Diagnostics.AddError(
			"Error reading Custom Certificate",
			fmt.Sprintf("Could not read the Custom Certificate: %s", err),
		)
		return
	}

	if customCertificate.Autogenerated || customCertificate.DNSChallenge {
		resp.Diagnostics.AddError("Autogenerated Certificate",
			"You cannot manage autogenerated certificates using this resource.\n"+
				fmt.Sprintf("The certificate with ID %d is autogenerated.", int(state.ID.ValueInt64())),
		)
		return
	}

	// Sort SAN domains
	sort.Strings(customCertificate.Domains)
	san_domains := strings.Join(customCertificate.Domains, ", ")

	// Parse expiration time
	expiration := customCertificate.Expiration
	exptoint, err := strconv.ParseFloat(customCertificate.Expiration, 64)
	if err == nil {
		expiration = time.Unix(int64(exptoint), 0).String()
	}

	state.ID = types.Int64Value(int64(customCertificate.ID))
	state.CommonName = types.StringValue(customCertificate.CommonName)
	state.Domains = types.StringValue(san_domains)
	state.Expiration = types.StringValue(expiration)
	if helpers.SanitizeStringForDiff(customCertificate.PublicKey) != helpers.SanitizeStringForDiff(state.PublicKey.ValueString()) {
		state.PublicKey = types.StringValue(customCertificate.PublicKey)
	}
	if helpers.SanitizeStringForDiff(customCertificate.PrivateKey) != helpers.SanitizeStringForDiff(state.PrivateKey.ValueString()) {
		state.PrivateKey = types.StringValue(customCertificate.PrivateKey)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete
func (r *customCertificateResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state CustomCertificate
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// 204 on successful delete
	tflog.Info(ctx, "Deleting Custom Certificate with ID: '"+state.ID.String()+"'")
	if err := r.client.DeleteCustomCertificate(int(state.ID.ValueInt64())); err != nil {
		resp.Diagnostics.AddError(
			"Error deleting a Custom Certificate",
			"Could not delete the Custom Certificate: "+state.ID.String()+"\n"+err.Error(),
		)
		return
	}
}

// Configure adds the provider configured client to the resource.
func (r *customCertificateResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*teclient.Client)
}

func (r *customCertificateResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	certID, err := strconv.Atoi(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Invalid identifier", "Certificate ID must be a valid number.")
		return
	}
	if certID <= 0 {
		resp.Diagnostics.AddError("Invalid identifier", "Certificate ID must be a valid number greater than 0.")
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), certID)...)
}
